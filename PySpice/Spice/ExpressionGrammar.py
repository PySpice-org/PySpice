#!/usr/bin/env python

# CAVEAT UTILITOR
#
# This file was automatically generated by TatSu.
#
#    https://pypi.python.org/pypi/tatsu/
#
# Any changes you make to it will be overwritten the next time
# the file is generated.

from __future__ import annotations

import sys

from tatsu.buffering import Buffer
from tatsu.parsing import Parser
from tatsu.parsing import tatsumasu
from tatsu.parsing import leftrec, nomemo, isname # noqa
from tatsu.infos import ParserConfig
from tatsu.util import re, generic_main  # noqa


KEYWORDS = {}  # type: ignore


class ExpressionBuffer(Buffer):
    def __init__(self, text, /, config: ParserConfig = None, **settings):
        config = ParserConfig.new(
            config,
            owner=self,
            whitespace=None,
            nameguard=None,
            comments_re=None,
            eol_comments_re=None,
            ignorecase=True,
            namechars='',
            parseinfo=True,
        )
        config = config.replace(**settings)
        super().__init__(text, config=config)


class ExpressionParser(Parser):
    def __init__(self, /, config: ParserConfig = None, **settings):
        config = ParserConfig.new(
            config,
            owner=self,
            whitespace=None,
            nameguard=None,
            comments_re=None,
            eol_comments_re=None,
            ignorecase=True,
            namechars='',
            parseinfo=True,
            keywords=KEYWORDS,
            start='start',
        )
        config = config.replace(**settings)
        super().__init__(config=config)

    @tatsumasu('SpiceExpression')
    @nomemo
    def _start_(self):  # noqa
        self._gen_expr_()

    @tatsumasu('GenericExpression')
    @nomemo
    def _gen_expr_(self):  # noqa
        with self._choice():
            with self._option():
                self._braced_expression_()
                self.name_last_node('braced')
            with self._option():
                self._value_()
                self.name_last_node('value')
            self._error(
                'expecting one of: '
                '<braced_expression> <expression>'
                '<imag_value> <lc> <real_value> <value>'
            )

    @tatsumasu('BracedExpression')
    @nomemo
    def _braced_expression_(self):  # noqa
        with self._choice():
            with self._option():
                self._lc_()
                with self._optional():
                    self._sep_()
                    self.name_last_node('sep')
                self._expression_()
                self.name_last_node('@')
                with self._optional():
                    self._sep_()
                    self.name_last_node('sep')
                self._rc_()

                self._define(
                    ['sep'],
                    []
                )
            with self._option():
                self._expression_()
                self.name_last_node('@')
            self._error(
                'expecting one of: '
                "'{' <expression> <lc> <term> <ternary>"
            )

    @tatsumasu('Expression')
    @leftrec
    def _expression_(self):  # noqa
        with self._choice():
            with self._option():
                self._ternary_()
                self.name_last_node('ternary')
            with self._option():
                self._term_()
                self.name_last_node('term')
            self._error(
                'expecting one of: '
                '<add_sub> <conditional_expression>'
                '<term> <ternary>'
            )

    @tatsumasu('Ternary')
    @nomemo
    def _ternary_(self):  # noqa
        self._conditional_expression_()
        self.name_last_node('t')
        with self._optional():
            self._sep_()
            self.name_last_node('sep')
        self._token('?')
        self.name_last_node('op')
        self._cut()
        with self._optional():
            self._sep_()
            self.name_last_node('sep')
        self._expression_()
        self.name_last_node('x')
        with self._optional():
            self._sep_()
            self.name_last_node('sep')
        self._token(':')
        self._cut()
        with self._optional():
            self._sep_()
            self.name_last_node('sep')
        self._expression_()
        self.name_last_node('y')

        self._define(
            ['op', 'sep', 't', 'x', 'y'],
            []
        )

    @tatsumasu('Conditional')
    @nomemo
    def _conditional_expression_(self):  # noqa
        self._boolean_or_()
        self.name_last_node('expr')

    @tatsumasu('Or')
    @nomemo
    def _boolean_or_(self):  # noqa
        self._boolean_xor_()
        self.name_last_node('left')
        with self._optional():
            with self._optional():
                self._sep_()
                self.name_last_node('sep')
            self._token('|')
            self.name_last_node('op')
            with self._optional():
                self._sep_()
                self.name_last_node('sep')
            self._boolean_or_()
            self.name_last_node('right')

            self._define(
                ['op', 'right', 'sep'],
                []
            )

        self._define(
            ['left', 'op', 'right', 'sep'],
            []
        )

    @tatsumasu('Xor')
    @nomemo
    def _boolean_xor_(self):  # noqa
        self._boolean_and_()
        self.name_last_node('left')
        with self._optional():
            with self._optional():
                self._sep_()
                self.name_last_node('sep')
            self._token('^')
            self.name_last_node('op')
            with self._optional():
                self._sep_()
                self.name_last_node('sep')
            self._boolean_xor_()
            self.name_last_node('right')

            self._define(
                ['op', 'right', 'sep'],
                []
            )

        self._define(
            ['left', 'op', 'right', 'sep'],
            []
        )

    @tatsumasu('And')
    @nomemo
    def _boolean_and_(self):  # noqa
        self._boolean_not_()
        self.name_last_node('left')
        with self._optional():
            with self._optional():
                self._sep_()
                self.name_last_node('sep')
            self._token('&')
            self.name_last_node('op')
            with self._optional():
                self._sep_()
                self.name_last_node('sep')
            self._boolean_and_()
            self.name_last_node('right')

            self._define(
                ['op', 'right', 'sep'],
                []
            )

        self._define(
            ['left', 'op', 'right', 'sep'],
            []
        )

    @tatsumasu('Not')
    @nomemo
    def _boolean_not_(self):  # noqa
        with self._optional():
            self._token('~')
            self.name_last_node('op')
        self._relational_()
        self.name_last_node('operator')

        self._define(
            ['op', 'operator'],
            []
        )

    @tatsumasu('Relational')
    @nomemo
    def _relational_(self):  # noqa
        with self._choice():
            with self._option():
                self._expression_()
                self.name_last_node('left')
                with self._optional():
                    self._sep_()
                    self.name_last_node('sep')
                with self._group():
                    with self._choice():
                        with self._option():
                            self._token('==')
                        with self._option():
                            self._token('!=')
                        with self._option():
                            self._token('>=')
                        with self._option():
                            self._token('<=')
                        with self._option():
                            self._token('>')
                        with self._option():
                            self._token('<')
                        self._error(
                            'expecting one of: '
                            "'!=' '<' '<=' '==' '>' '>='"
                        )
                self.name_last_node('op')
                with self._optional():
                    self._sep_()
                    self.name_last_node('sep')
                self._expression_()
                self.name_last_node('right')

                self._define(
                    ['left', 'op', 'right', 'sep'],
                    []
                )
            with self._option():
                self._conditional_factor_()
                self.name_last_node('factor')
            self._error(
                'expecting one of: '
                '<add_sub> <boolean>'
                '<conditional_expression>'
                '<conditional_factor> <expression> <lp>'
                '<term> <ternary>'
            )

    @tatsumasu('ConditionalFactor')
    def _conditional_factor_(self):  # noqa
        with self._choice():
            with self._option():
                self._lp_()
                with self._optional():
                    self._sep_()
                    self.name_last_node('sep')
                self._conditional_expression_()
                self.name_last_node('expr')
                with self._optional():
                    self._sep_()
                    self.name_last_node('sep')
                self._rp_()

                self._define(
                    ['expr', 'sep'],
                    []
                )
            with self._option():
                self._boolean_()
                self.name_last_node('boolean')
            self._error(
                'expecting one of: '
                "'(' 'FALSE' 'TRUE' <boolean> <lp>"
            )

    @tatsumasu('Term')
    def _term_(self):  # noqa
        self._add_sub_()
        self.name_last_node('@')

    @tatsumasu('AddSub')
    def _add_sub_(self):  # noqa
        self._prod_()
        self.name_last_node('left')
        with self._optional():
            with self._optional():
                self._sep_()
                self.name_last_node('sep')
            with self._group():
                with self._choice():
                    with self._option():
                        self._token('+')
                    with self._option():
                        self._token('-')
                    self._error(
                        'expecting one of: '
                        "'+' '-'"
                    )
            self.name_last_node('op')
            with self._optional():
                self._sep_()
                self.name_last_node('sep')
            self._add_sub_()
            self.name_last_node('right')

            self._define(
                ['op', 'right', 'sep'],
                []
            )

        self._define(
            ['left', 'op', 'right', 'sep'],
            []
        )

    @tatsumasu('ProdDivMod')
    def _prod_(self):  # noqa
        self._unary_()
        self.name_last_node('left')
        with self._optional():
            with self._optional():
                self._sep_()
                self.name_last_node('sep')
            with self._group():
                with self._choice():
                    with self._option():
                        self._token('*')
                    with self._option():
                        self._token('/')
                    with self._option():
                        self._token('%')
                    self._error(
                        'expecting one of: '
                        "'%' '*' '/'"
                    )
            self.name_last_node('op')
            with self._optional():
                self._sep_()
                self.name_last_node('sep')
            self._prod_()
            self.name_last_node('right')

            self._define(
                ['op', 'right', 'sep'],
                []
            )

        self._define(
            ['left', 'op', 'right', 'sep'],
            []
        )

    @tatsumasu('Sign')
    def _unary_(self):  # noqa
        with self._optional():
            with self._group():
                with self._choice():
                    with self._option():
                        self._token('+')
                    with self._option():
                        self._token('-')
                    self._error(
                        'expecting one of: '
                        "'+' '-'"
                    )
            self.name_last_node('op')
        self._exp_()
        self.name_last_node('operator')

        self._define(
            ['op', 'operator'],
            []
        )

    @tatsumasu('Exponential')
    def _exp_(self):  # noqa
        self._functional_()
        self.name_last_node('left')
        with self._optional():
            with self._optional():
                self._sep_()
                self.name_last_node('sep')
            self._token('**')
            self.name_last_node('op')
            with self._optional():
                self._sep_()
                self.name_last_node('sep')
            self._exp_()
            self.name_last_node('right')

            self._define(
                ['op', 'right', 'sep'],
                []
            )

        self._define(
            ['left', 'op', 'right', 'sep'],
            []
        )

    @tatsumasu('Functional')
    def _functional_(self):  # noqa
        with self._choice():
            with self._option():
                self._functions_()
                self.name_last_node('@')
            with self._option():
                self._variable_()
                self.name_last_node('@')
            self._error(
                'expecting one of: '
                '<atan2> <ddx> <factor> <functions>'
                '<functions_1> <functions_2> <gauss>'
                '<i_func> <if_func> <lc> <limit> <rand>'
                '<unif> <v_func> <var_id> <variable>'
            )

    @tatsumasu('Variable')
    def _variable_(self):  # noqa
        with self._choice():
            with self._option():
                self._lc_()
                with self._optional():
                    self._sep_()
                    self.name_last_node('sep')
                self._var_id_()
                self.name_last_node('variable')
                with self._optional():
                    self._sep_()
                    self.name_last_node('sep')
                self._rc_()

                self._define(
                    ['sep', 'variable'],
                    []
                )
            with self._option():
                self._var_id_()
                self.name_last_node('variable')
            with self._option():
                self._factor_()
                self.name_last_node('factor')
            self._error(
                'expecting one of: '
                "'{' <factor> <lc> <lp> <value> <var_id>"
                '[a-zA-Z] [a-zA-Z_`@#\\$][a-zA-Z0-'
                '9_:`@#\\.\\$]*[a-zA-Z0-9_`@#\\.\\$]'
            )

    @tatsumasu('Factor')
    def _factor_(self):  # noqa
        with self._choice():
            with self._option():
                self._lp_()
                with self._optional():
                    self._sep_()
                    self.name_last_node('sep')
                self._expression_()
                self.name_last_node('@')
                with self._optional():
                    self._sep_()
                    self.name_last_node('sep')
                self._rp_()

                self._define(
                    ['sep'],
                    []
                )
            with self._option():
                self._value_()
                self.name_last_node('@')
            self._error(
                'expecting one of: '
                "'(' <imag_value> <lp> <real_value>"
                '<value>'
            )

    @tatsumasu('Functions')
    def _functions_(self):  # noqa
        with self._choice():
            with self._option():
                self._functions_1_()
            with self._option():
                self._atan2_()
            with self._option():
                self._ddx_()
            with self._option():
                self._gauss_()
            with self._option():
                self._if_func_()
            with self._option():
                self._limit_()
            with self._option():
                self._functions_2_()
            with self._option():
                self._rand_()
            with self._option():
                self._unif_()
            with self._option():
                self._i_func_()
            with self._option():
                self._v_func_()
            self._error(
                'expecting one of: '
                "'Img' 'Ph' 'R' 'Re' 'abs' 'acos' 'acosh'"
                "'agauss' 'arctan' 'asin' 'asinh' 'atan'"
                "'atan2' 'atanh' 'aunif' 'ceil' 'cos'"
                "'cosh' 'ddt' 'ddx' 'exp' 'floor' 'gauss'"
                "'i' 'if' 'int' 'limit' 'ln' 'log'"
                "'log10' 'm' 'max' 'min' 'nint' 'pow'"
                "'pwr' 'pwrs' 'rand' 'sdt' 'sgn' 'sign'"
                "'sin' 'sinh' 'sqrt' 'stp' 'tan' 'tanh'"
                "'unif' 'uramp' 'v' <functions_1>"
                '<functions_2> <i_func> <if_func>'
                '<v_func>'
            )

    @tatsumasu()
    def _functions_1_(self):  # noqa
        with self._group():
            with self._choice():
                with self._option():
                    self._token('abs')
                with self._option():
                    self._token('ceil')
                with self._option():
                    self._token('ddt')
                with self._option():
                    self._token('floor')
                with self._option():
                    self._token('int')
                with self._option():
                    self._token('m')
                with self._option():
                    self._token('nint')
                with self._option():
                    self._token('sdt')
                with self._option():
                    self._token('sgn')
                with self._option():
                    self._token('stp')
                with self._option():
                    self._token('sqrt')
                with self._option():
                    self._token('uramp')
                with self._option():
                    self._token('Ph')
                with self._option():
                    self._token('Re')
                with self._option():
                    self._token('R')
                with self._option():
                    self._token('Img')
                with self._option():
                    self._token('acosh')
                with self._option():
                    self._token('acos')
                with self._option():
                    self._token('asinh')
                with self._option():
                    self._token('asin')
                with self._option():
                    self._token('arctan')
                with self._option():
                    self._token('atanh')
                with self._option():
                    self._token('atan')
                with self._option():
                    self._token('cosh')
                with self._option():
                    self._token('cos')
                with self._option():
                    self._token('exp')
                with self._option():
                    self._token('ln')
                with self._option():
                    self._token('log')
                with self._option():
                    self._token('log10')
                with self._option():
                    self._token('sinh')
                with self._option():
                    self._token('sin')
                with self._option():
                    self._token('tanh')
                with self._option():
                    self._token('tan')
                self._error(
                    'expecting one of: '
                    "'Img' 'Ph' 'R' 'Re' 'abs' 'acos' 'acosh'"
                    "'arctan' 'asin' 'asinh' 'atan' 'atanh'"
                    "'ceil' 'cos' 'cosh' 'ddt' 'exp' 'floor'"
                    "'int' 'ln' 'log' 'log10' 'm' 'nint'"
                    "'sdt' 'sgn' 'sin' 'sinh' 'sqrt' 'stp'"
                    "'tan' 'tanh' 'uramp'"
                )
        self.name_last_node('func')
        with self._optional():
            self._sep_()
            self.name_last_node('sep')
        self._lp_()
        self._cut()
        with self._optional():
            self._sep_()
            self.name_last_node('sep')
        self._expression_()
        self.name_last_node('x')
        with self._optional():
            self._sep_()
            self.name_last_node('sep')
        self._rp_()

        self._define(
            ['func', 'sep', 'x'],
            []
        )

    @tatsumasu()
    def _atan2_(self):  # noqa
        self._token('atan2')
        self.name_last_node('func')
        with self._optional():
            self._sep_()
            self.name_last_node('sep')
        self._lp_()
        self._cut()
        with self._optional():
            self._sep_()
            self.name_last_node('sep')
        self._expression_()
        self.name_last_node('y')
        with self._optional():
            self._sep_()
            self.name_last_node('sep')
        self._comma_()
        with self._optional():
            self._sep_()
            self.name_last_node('sep')
        self._expression_()
        self.name_last_node('x')
        with self._optional():
            self._sep_()
            self.name_last_node('sep')
        self._rp_()

        self._define(
            ['func', 'sep', 'x', 'y'],
            []
        )

    @tatsumasu()
    def _ddx_(self):  # noqa
        self._token('ddx')
        self.name_last_node('func')
        with self._optional():
            self._sep_()
            self.name_last_node('sep')
        self._lp_()
        self._cut()
        with self._optional():
            self._sep_()
            self.name_last_node('sep')
        self._id_()
        self.name_last_node('f')
        with self._optional():
            self._sep_()
            self.name_last_node('sep')
        self._comma_()
        with self._optional():
            self._sep_()
            self.name_last_node('sep')
        self._expression_()
        self.name_last_node('x')
        with self._optional():
            self._sep_()
            self.name_last_node('sep')
        self._rp_()

        self._define(
            ['f', 'func', 'sep', 'x'],
            []
        )

    @tatsumasu()
    def _gauss_(self):  # noqa
        with self._group():
            with self._choice():
                with self._option():
                    self._token('agauss')
                with self._option():
                    self._token('gauss')
                self._error(
                    'expecting one of: '
                    "'agauss' 'gauss'"
                )
        self.name_last_node('func')
        with self._optional():
            self._sep_()
            self.name_last_node('sep')
        self._lp_()
        self._cut()
        with self._optional():
            self._sep_()
            self.name_last_node('sep')
        self._expression_()
        self.name_last_node('mu')
        with self._optional():
            self._sep_()
            self.name_last_node('sep')
        self._comma_()
        with self._optional():
            self._sep_()
            self.name_last_node('sep')
        self._expression_()
        self.name_last_node('alpha')
        with self._optional():
            self._sep_()
            self.name_last_node('sep')
        self._comma_()
        with self._optional():
            self._sep_()
            self.name_last_node('sep')
        self._expression_()
        self.name_last_node('n')
        with self._optional():
            self._sep_()
            self.name_last_node('sep')
        self._rp_()

        self._define(
            ['alpha', 'func', 'mu', 'n', 'sep'],
            []
        )

    @tatsumasu()
    def _i_func_(self):  # noqa
        self._token('i')
        self.name_last_node('func')
        with self._optional():
            self._sep_()
            self.name_last_node('sep')
        self._lp_()
        self._cut()
        with self._optional():
            self._sep_()
            self.name_last_node('sep')
        with self._if():
            self._token('V')
        self._dev_()
        self.name_last_node('device')
        with self._optional():
            self._sep_()
            self.name_last_node('sep')
        self._rp_()

        self._define(
            ['device', 'func', 'sep'],
            []
        )

    @tatsumasu()
    def _if_func_(self):  # noqa
        self._token('if')
        self.name_last_node('func')
        with self._optional():
            self._sep_()
            self.name_last_node('sep')
        self._lp_()
        self._cut()
        with self._optional():
            self._sep_()
            self.name_last_node('sep')
        self._conditional_expression_()
        self.name_last_node('t')
        with self._optional():
            self._sep_()
            self.name_last_node('sep')
        self._comma_()
        with self._optional():
            self._sep_()
            self.name_last_node('sep')
        self._expression_()
        self.name_last_node('x')
        with self._optional():
            self._sep_()
            self.name_last_node('sep')
        self._comma_()
        with self._optional():
            self._sep_()
            self.name_last_node('sep')
        self._expression_()
        self.name_last_node('y')
        with self._optional():
            self._sep_()
            self.name_last_node('sep')
        self._rp_()

        self._define(
            ['func', 'sep', 't', 'x', 'y'],
            []
        )

    @tatsumasu()
    def _limit_(self):  # noqa
        self._token('limit')
        self.name_last_node('func')
        with self._optional():
            self._sep_()
            self.name_last_node('sep')
        self._lp_()
        self._cut()
        with self._optional():
            self._sep_()
            self.name_last_node('sep')
        self._expression_()
        self.name_last_node('x')
        with self._optional():
            self._sep_()
            self.name_last_node('sep')
        self._comma_()
        with self._optional():
            self._sep_()
            self.name_last_node('sep')
        self._expression_()
        self.name_last_node('y')
        with self._optional():
            self._sep_()
            self.name_last_node('sep')
        self._comma_()
        with self._optional():
            self._sep_()
            self.name_last_node('sep')
        self._expression_()
        self.name_last_node('z')
        with self._optional():
            self._sep_()
            self.name_last_node('sep')
        self._rp_()

        self._define(
            ['func', 'sep', 'x', 'y', 'z'],
            []
        )

    @tatsumasu()
    def _functions_2_(self):  # noqa
        with self._group():
            with self._choice():
                with self._option():
                    self._token('min')
                with self._option():
                    self._token('max')
                with self._option():
                    self._token('pwrs')
                with self._option():
                    self._token('pow')
                with self._option():
                    self._token('pwr')
                with self._option():
                    self._token('sign')
                self._error(
                    'expecting one of: '
                    "'max' 'min' 'pow' 'pwr' 'pwrs' 'sign'"
                )
        self.name_last_node('func')
        with self._optional():
            self._sep_()
            self.name_last_node('sep')
        self._lp_()
        self._cut()
        with self._optional():
            self._sep_()
            self.name_last_node('sep')
        self._expression_()
        self.name_last_node('x')
        with self._optional():
            self._sep_()
            self.name_last_node('sep')
        self._comma_()
        with self._optional():
            self._sep_()
            self.name_last_node('sep')
        self._expression_()
        self.name_last_node('y')
        with self._optional():
            self._sep_()
            self.name_last_node('sep')
        self._rp_()

        self._define(
            ['func', 'sep', 'x', 'y'],
            []
        )

    @tatsumasu()
    def _rand_(self):  # noqa
        self._token('rand')
        self.name_last_node('func')
        with self._optional():
            self._sep_()
            self.name_last_node('sep')
        self._lp_()
        self._cut()
        with self._optional():
            self._sep_()
            self.name_last_node('sep')
        self._rp_()

        self._define(
            ['func', 'sep'],
            []
        )

    @tatsumasu()
    def _unif_(self):  # noqa
        with self._group():
            with self._choice():
                with self._option():
                    self._token('aunif')
                with self._option():
                    self._token('unif')
                self._error(
                    'expecting one of: '
                    "'aunif' 'unif'"
                )
        self.name_last_node('func')
        with self._optional():
            self._sep_()
            self.name_last_node('sep')
        self._lp_()
        self._cut()
        with self._optional():
            self._sep_()
            self.name_last_node('sep')
        self._expression_()
        self.name_last_node('mu')
        with self._optional():
            self._sep_()
            self.name_last_node('sep')
        self._comma_()
        with self._optional():
            self._sep_()
            self.name_last_node('sep')
        self._expression_()
        self.name_last_node('alpha')
        with self._optional():
            self._sep_()
            self.name_last_node('sep')
        self._rp_()

        self._define(
            ['alpha', 'func', 'mu', 'sep'],
            []
        )

    @tatsumasu()
    def _v_func_(self):  # noqa
        self._token('v')
        self.name_last_node('func')
        with self._optional():
            self._sep_()
            self.name_last_node('sep')
        self._lp_()
        self._cut()
        with self._optional():
            self._sep_()
            self.name_last_node('sep')
        self._node_()
        self.name_last_node('node')
        with self._optional():
            self._sep_()
            self.name_last_node('sep')
        with self._optional():
            self._comma_()
            with self._optional():
                self._sep_()
                self.name_last_node('sep')
            self._node_()
            self.name_last_node('node')
            with self._optional():
                self._sep_()
                self.name_last_node('sep')

            self._define(
                ['node', 'sep'],
                []
            )
        self._rp_()

        self._define(
            ['func', 'node', 'sep'],
            []
        )

    @tatsumasu()
    def _special_variables_(self):  # noqa
        with self._choice():
            with self._option():
                self._token('time')
            with self._option():
                self._token('temper')
            with self._option():
                self._token('temp')
            with self._option():
                self._token('freq')
            with self._option():
                self._token('vt')
            with self._option():
                self._token('pi')
            self._error(
                'expecting one of: '
                "'freq' 'pi' 'temp' 'temper' 'time' 'vt'"
            )

    @tatsumasu('Value')
    def _value_(self):  # noqa
        with self._group():
            with self._choice():
                with self._option():
                    with self._group():
                        self._real_value_()
                        self.name_last_node('real')
                        self._token('+')
                        self._imag_value_()
                        self.name_last_node('imag')

                        self._define(
                            ['imag', 'real'],
                            []
                        )
                with self._option():
                    self._imag_value_()
                    self.name_last_node('imag')
                with self._option():
                    self._real_value_()
                    self.name_last_node('real')
                self._error(
                    'expecting one of: '
                    '<imag_value> <real_value>'
                )
        with self._optional():
            with self._choice():
                with self._option():
                    self._hz_()
                with self._option():
                    self._unit_()
                self._error(
                    'expecting one of: '
                    '<hz> <unit>'
                )
        self.name_last_node('unit')

        self._define(
            ['imag', 'real', 'unit'],
            []
        )

    @tatsumasu('ImagValue')
    def _imag_value_(self):  # noqa
        self._number_scale_()
        self.name_last_node('value')
        self._token('J')

        self._define(
            ['value'],
            []
        )

    @tatsumasu('RealValue')
    def _real_value_(self):  # noqa
        self._number_scale_()
        self.name_last_node('value')

    @tatsumasu()
    def _freq_value_(self):  # noqa
        self._number_scale_()
        self.name_last_node('value')
        with self._optional():
            self._hz_()
        self.name_last_node('unit')

        self._define(
            ['unit', 'value'],
            []
        )

    @tatsumasu('NumberScale')
    def _number_scale_(self):  # noqa
        with self._choice():
            with self._option():
                self._floating_point_()
                self.name_last_node('value')
                with self._group():
                    with self._choice():
                        with self._option():
                            self._meg_()
                        with self._option():
                            with self._optional():
                                self._suffix_()
                        self._error(
                            'expecting one of: '
                            '<meg> <suffix>'
                        )
                self.name_last_node('scale')

                self._define(
                    ['scale', 'value'],
                    []
                )
            with self._option():
                self._integer_()
                self.name_last_node('value')
                with self._group():
                    with self._choice():
                        with self._option():
                            self._meg_()
                        with self._option():
                            with self._optional():
                                self._suffix_()
                        self._error(
                            'expecting one of: '
                            '<meg> <suffix>'
                        )
                self.name_last_node('scale')

                self._define(
                    ['scale', 'value'],
                    []
                )
            self._error(
                'expecting one of: '
                '([\\+\\-]?(([0-9]+(\\.[0-9]*)?)|(\\.[0-'
                '9]+))([eE][\\-\\+]?[0-9]{1,3})?)'
                '([\\+\\-]?[0-9]+) <floating_point>'
                '<integer>'
            )

    @tatsumasu()
    def _suffix_(self):  # noqa
        self._pattern('[tTgGkKmMxXuUnNpPfFµ]')

    @tatsumasu()
    def _meg_(self):  # noqa
        self._pattern('[mM][eE][gG]')

    @tatsumasu('Unit')
    def _unit_(self):  # noqa
        self._pattern('[a-zA-Z%]+')

    @tatsumasu('Hz')
    def _hz_(self):  # noqa
        self._pattern('[Hh][Zz]')

    @tatsumasu()
    def _lead_name_(self):  # noqa
        self._pattern('I[SDGBEC1-9]')

    @tatsumasu('Float')
    def _floating_point_(self):  # noqa
        self._pattern('([\\+\\-]?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))([eE][\\-\\+]?[0-9]{1,3})?)')

    @tatsumasu('Int')
    def _integer_(self):  # noqa
        self._pattern('([\\+\\-]?[0-9]+)')

    @tatsumasu()
    def _digit_(self):  # noqa
        self._pattern('[0-9]')

    @tatsumasu()
    def _boolean_(self):  # noqa
        with self._choice():
            with self._option():
                self._token('TRUE')
            with self._option():
                self._token('FALSE')
            self._error(
                'expecting one of: '
                "'FALSE' 'TRUE'"
            )

    @tatsumasu('BinaryPattern')
    def _binary_pattern_(self):  # noqa
        self._pattern('[Bb]')

        def block1():
            self._binary_()
        self._positive_closure(block1)
        self.name_last_node('pattern')

        self._define(
            ['pattern'],
            []
        )

    @tatsumasu()
    def _binary_(self):  # noqa
        self._pattern('[01]')

    @tatsumasu('Device')
    def _dev_(self):  # noqa
        self._pattern('[a-zA-Z\\$][a-zA-Z0-9_:!`@#\\.\\+\\-\\$]*')

    @tatsumasu('NetNode')
    def _node_(self):  # noqa
        with self._group():
            with self._choice():
                with self._option():
                    self._pattern('[a-zA-Z0-9_\\[\\$\\/\\+\\-][a-zA-Z0-9_:\\$\\-`~!@#%&_\\+|<>\\?\\.\\\\|\\^\\*\\/]*[a-zA-Z0-9_\\$\\-`~!@#%&_\\+|<>\\?\\.\\\\|\\^\\*\\]\\/]')
                with self._option():
                    self._pattern('[a-zA-Z0-9_]')
                self._error(
                    'expecting one of: '
                    '[a-zA-Z0-9_\\[\\$\\/\\+\\-][a-zA-Z0-9_:\\$\\-'
                    '`~!@#%&_\\+|<>\\?\\.\\|\\^\\*\\/]*[a-zA-Z0-'
                    '9_\\$\\-`~!@#%&_\\+|<>\\?\\.\\|\\^\\*\\]\\/]'
                    '[a-zA-Z0-9_]'
                )
        self.name_last_node('node')
        with self._ifnot():
            with self._group():
                with self._optional():
                    self._sep_()
                    self.name_last_node('sep')
                self._token('=')

                self._define(
                    ['sep'],
                    []
                )

        self._define(
            ['node', 'sep'],
            []
        )

    @tatsumasu()
    def _id_(self):  # noqa
        with self._choice():
            with self._option():
                self._pattern('[a-zA-Z_`@#\\$][a-zA-Z0-9_:`@#\\.\\$\\/]*[a-zA-Z0-9_`@#\\.\\$]')
            with self._option():
                self._pattern('[a-zA-Z_`@#\\$]')
            self._error(
                'expecting one of: '
                '[a-zA-Z_`@#\\$] [a-zA-Z_`@#\\$][a-zA-Z0-'
                '9_:`@#\\.\\$\\/]*[a-zA-Z0-9_`@#\\.\\$]'
            )

    @tatsumasu()
    def _var_id_(self):  # noqa
        with self._choice():
            with self._option():
                self._pattern('[a-zA-Z_`@#\\$][a-zA-Z0-9_:`@#\\.\\$]*[a-zA-Z0-9_`@#\\.\\$]')
            with self._option():
                self._pattern('[a-zA-Z]')
            self._error(
                'expecting one of: '
                '[a-zA-Z] [a-zA-Z_`@#\\$][a-zA-Z0-'
                '9_:`@#\\.\\$]*[a-zA-Z0-9_`@#\\.\\$]'
            )

    @tatsumasu()
    def _end_sep_(self):  # noqa
        with self._choice():
            with self._option():
                self._cmd_net_sep_()
                self.name_last_node('@')

                def block2():
                    self._st_()
                self._closure(block2)
            with self._option():

                def block3():
                    self._st_()
                self._positive_closure(block3)
            self._error(
                'expecting one of: '
                '<cmd_net_sep> <inline_comment> <newline>'
                '<st> [ \\t]'
            )

    @tatsumasu()
    def _sep_(self):  # noqa
        with self._choice():
            with self._option():

                def block1():
                    self._cmd_net_sep_()
                    self.name_last_node('@')

                    def block3():
                        self._st_()
                    self._closure(block3)
                    self._token('+')

                    def block4():
                        self._st_()
                    self._closure(block4)
                self._positive_closure(block1)
            with self._option():

                def block5():
                    self._st_()
                self._positive_closure(block5)
            self._error(
                'expecting one of: '
                '<cmd_net_sep> <inline_comment> <newline>'
                '<st> [ \\t]'
            )

    @tatsumasu('Separator')
    def _cmd_net_sep_(self):  # noqa

        def block0():
            self._st_()
        self._closure(block0)
        with self._optional():
            self._inline_comment_()
            self.name_last_node('@')
        self.name_last_node('comment')
        self._newline_()

        def block3():

            def block4():
                self._st_()
            self._closure(block4)
            with self._optional():
                with self._choice():
                    with self._option():
                        self._line_comment_()
                        self.name_last_node('@')
                    with self._option():
                        self._inline_comment_()
                        self.name_last_node('@')
                    self._error(
                        'expecting one of: '
                        '<inline_comment> <line_comment>'
                    )
            self.name_last_node('comment')
            self._newline_()

            self._define(
                ['comment'],
                []
            )
        self._closure(block3)

        self._define(
            ['comment'],
            []
        )

    @tatsumasu()
    def _inline_comment_(self):  # noqa
        self._semicolon_()

        def block0():
            self._st_()
        self._closure(block0)
        self._text_()
        self.name_last_node('@')

    @tatsumasu()
    def _line_comment_(self):  # noqa
        self._asterisk_()

        def block0():
            self._st_()
        self._closure(block0)
        self._text_()
        self.name_last_node('@')

    @tatsumasu('Comment')
    def _text_(self):  # noqa
        self._pattern('[^\\r\\n]*')

    @tatsumasu()
    def _asterisk_(self):  # noqa
        self._token('*')

    @tatsumasu()
    def _question_mark_(self):  # noqa
        self._token('?')

    @tatsumasu()
    def _colon_(self):  # noqa
        self._token(':')

    @tatsumasu()
    def _semicolon_(self):  # noqa
        self._token(';')

    @tatsumasu()
    def _comma_(self):  # noqa
        self._token(',')

    @tatsumasu()
    def _dot_(self):  # noqa
        self._token('.')

    @tatsumasu()
    def _dollar_(self):  # noqa
        self._token('\\$')

    @tatsumasu()
    def _double_bar_(self):  # noqa
        self._token('//')

    @tatsumasu()
    def _single_quote_(self):  # noqa
        self._token("'")

    @tatsumasu()
    def _double_quote_(self):  # noqa
        self._token('"')

    @tatsumasu()
    def _lc_(self):  # noqa
        self._token('{')

    @tatsumasu()
    def _rc_(self):  # noqa
        self._token('}')

    @tatsumasu()
    def _lp_(self):  # noqa
        self._token('(')

    @tatsumasu()
    def _rp_(self):  # noqa
        self._token(')')

    @tatsumasu()
    def _newline_(self):  # noqa
        self._pattern('[\\r\\n]')

    @tatsumasu()
    def _st_(self):  # noqa
        self._pattern('[ \\t]')

    @tatsumasu()
    def _ws_(self):  # noqa
        self._pattern('[^\\S\\r\\n]*')


class ExpressionSemantics:
    def start(self, ast):  # noqa
        return ast

    def gen_expr(self, ast):  # noqa
        return ast

    def braced_expression(self, ast):  # noqa
        return ast

    def expression(self, ast):  # noqa
        return ast

    def ternary(self, ast):  # noqa
        return ast

    def conditional_expression(self, ast):  # noqa
        return ast

    def boolean_or(self, ast):  # noqa
        return ast

    def boolean_xor(self, ast):  # noqa
        return ast

    def boolean_and(self, ast):  # noqa
        return ast

    def boolean_not(self, ast):  # noqa
        return ast

    def relational(self, ast):  # noqa
        return ast

    def conditional_factor(self, ast):  # noqa
        return ast

    def term(self, ast):  # noqa
        return ast

    def add_sub(self, ast):  # noqa
        return ast

    def prod(self, ast):  # noqa
        return ast

    def unary(self, ast):  # noqa
        return ast

    def exp(self, ast):  # noqa
        return ast

    def functional(self, ast):  # noqa
        return ast

    def variable(self, ast):  # noqa
        return ast

    def factor(self, ast):  # noqa
        return ast

    def functions(self, ast):  # noqa
        return ast

    def functions_1(self, ast):  # noqa
        return ast

    def atan2(self, ast):  # noqa
        return ast

    def ddx(self, ast):  # noqa
        return ast

    def gauss(self, ast):  # noqa
        return ast

    def i_func(self, ast):  # noqa
        return ast

    def if_func(self, ast):  # noqa
        return ast

    def limit(self, ast):  # noqa
        return ast

    def functions_2(self, ast):  # noqa
        return ast

    def rand(self, ast):  # noqa
        return ast

    def unif(self, ast):  # noqa
        return ast

    def v_func(self, ast):  # noqa
        return ast

    def special_variables(self, ast):  # noqa
        return ast

    def value(self, ast):  # noqa
        return ast

    def imag_value(self, ast):  # noqa
        return ast

    def real_value(self, ast):  # noqa
        return ast

    def freq_value(self, ast):  # noqa
        return ast

    def number_scale(self, ast):  # noqa
        return ast

    def suffix(self, ast):  # noqa
        return ast

    def meg(self, ast):  # noqa
        return ast

    def unit(self, ast):  # noqa
        return ast

    def hz(self, ast):  # noqa
        return ast

    def lead_name(self, ast):  # noqa
        return ast

    def floating_point(self, ast):  # noqa
        return ast

    def integer(self, ast):  # noqa
        return ast

    def digit(self, ast):  # noqa
        return ast

    def boolean(self, ast):  # noqa
        return ast

    def binary_pattern(self, ast):  # noqa
        return ast

    def binary(self, ast):  # noqa
        return ast

    def dev(self, ast):  # noqa
        return ast

    def node(self, ast):  # noqa
        return ast

    def id(self, ast):  # noqa
        return ast

    def var_id(self, ast):  # noqa
        return ast

    def end_sep(self, ast):  # noqa
        return ast

    def sep(self, ast):  # noqa
        return ast

    def cmd_net_sep(self, ast):  # noqa
        return ast

    def inline_comment(self, ast):  # noqa
        return ast

    def line_comment(self, ast):  # noqa
        return ast

    def text(self, ast):  # noqa
        return ast

    def asterisk(self, ast):  # noqa
        return ast

    def question_mark(self, ast):  # noqa
        return ast

    def colon(self, ast):  # noqa
        return ast

    def semicolon(self, ast):  # noqa
        return ast

    def comma(self, ast):  # noqa
        return ast

    def dot(self, ast):  # noqa
        return ast

    def dollar(self, ast):  # noqa
        return ast

    def double_bar(self, ast):  # noqa
        return ast

    def single_quote(self, ast):  # noqa
        return ast

    def double_quote(self, ast):  # noqa
        return ast

    def lc(self, ast):  # noqa
        return ast

    def rc(self, ast):  # noqa
        return ast

    def lp(self, ast):  # noqa
        return ast

    def rp(self, ast):  # noqa
        return ast

    def newline(self, ast):  # noqa
        return ast

    def st(self, ast):  # noqa
        return ast

    def ws(self, ast):  # noqa
        return ast


def main(filename, **kwargs):
    if not filename or filename == '-':
        text = sys.stdin.read()
    else:
        with open(filename) as f:
            text = f.read()
    parser = ExpressionParser()
    return parser.parse(
        text,
        filename=filename,
        **kwargs
    )


if __name__ == '__main__':
    import json
    from tatsu.util import asjson

    ast = generic_main(main, ExpressionParser, name='Expression')
    data = asjson(ast)
    print(json.dumps(data, indent=2))
